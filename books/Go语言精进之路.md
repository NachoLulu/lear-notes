# Go语言精进之路

> 读书笔记

## 典型项目结构

Go语言典型项目结构按照用途可分为四类

#### 最小标准布局

Go官方并未给出应用项目的标准布局是怎样的，不过Go语言的技术负责人 Russ Cox曾在一个开源项目的issue上给出过他关于最小标准布局的一个想法。

```
-go.mod
-LICENSE
-xx.go
-yy.go
...
或
-go.mod
-LICENSE
-package1
	-package1.go
-package2
	-package2.go
```

pkg、docs、cmd这些目录不应该成为最小标准布局的标准结构的一部分，Go社区崇尚`简单`，故此标准结构足以灵活满足各种Go项目的需求。

#### 以构建二进制可执行文件为用途

关于此用途，其实Go社区也未给出一个标准的布局格式，即为Go社区中`非官方标准的建议结构布局`，也就是Gopher之间们默认约定成俗一种用途结构。

```
GoProject
|-LICENSE
|-Makefile
|-README.md
|-cmd/
|	|-app1/
|	|-main.go
|	|-app2/
|	|-main.go
|-go.mod
|-go.sum
|-pkg/
|	|-lib1/
|	|-lib1.go
|	|-lib2/
|	|-lib2.go
|-[vendor/]
```

pkg目录下主要是存放项目自身实现或引用的一些库文件，该目录下的包可被外部项目引用，算是个项目导出包的一个聚合。并且在Go语言1.4版本中去掉了此层目录，将所有包平铺到项目的根目录下，我认为当项目结构并不复杂的情况下可以此样设计，但是当项目结构或者内嵌的库文件过多时，建议还是使用此层目录，防止显着拥挤，保持简洁。

Makefile只是项目构建工具所用脚本的一个`代表`，可代表任何第三方构建工具所用的脚本，例：Jenkins使用的jenkinsfile；当然当构建脚本过多的时候可以使用build目录存放。

vendor目录为可选目录，按照需求来选择是否使用；vendor是Go1.5版本引入的用于项目本地缓存特定版本以来包的机制，现在Go的包管理工具一般都是使用Go module，当然Go module机制也保留了vendor目录（通过 `go mod vendor`可以生成vendor下的依赖包通过`go build -mod=vendor`可以实现基于vendor目录的构建），因此这里对vendor作为一个可选目录。

#### 以只为构建库为用途

此用途即为只为提供自身的库文件供其他项目调用。

```
GoLibProject
|-LICENSE
|-Makefile
|-README.md
|-go.mod
|-go.sum
|-lib.go
|-lib1/
|	|-lib1.go
|-lib2/
|	|-lib2.go
```

与构建二进制文件用途对比，去掉了cmd、pkg两个子目录，由于构建库没必要存放二进制文件的源码文件，并且由于此类项目就是为了对外开放暴露API接口，所以就没必要存放pkg目录。

vendor也不再作为可选目录了，因为构建库仅通过go.mod进行管理，故venrdor也就没有了存在的必要了。

#### 关于internal目录

无论是上述哪种类型的Go项目，对于不想暴露给外部使用，仅限于项目内部使用的包，在项目结构想可以通过Go1.4版本中引入的internal包机制来实现。

以库文件为例，最简单就是在顶层加个internal目录，将不想暴露到外部的包都存放到该目录下，比如下面的lib1、lib2：

```
GoLibProject
|-LICENSE
|-Makefile
|-README.md
|-go.mod
|-internal/
|	|-lib1/
|	|-lib2/
|-lib.go
|-lib1/
|	|-lib1.go
|-lib2/
|	|-lib2.go
```

根据Go internal机制的作用原理，internal目录下的lib1、lib2可被以GoLibProject作为根目录的其他目录的代码所导入和调用，但是不可被不以GoLibProject作为根目录以外的代码所引用使用。

## 命名惯例

命名保持简单一致性即可。

#### 包

一般建议以小写形式的单个单词命名；无需考虑是否重名，在Go中包名可以不唯一；包名应尽量与包导入路径（import path）的最后一个路径分段保持一致；命名时不仅要考虑包自身名字，还要兼顾该包导出的标识符（变量、常量、类型、函数等）的命名，尽量不再读得时候出现`口吃`。

#### 变量、类型、函数和方法

> 1. 循环和条件变量多采用单个字符命名
> 2. 函数/方法的参数和返回值变量以单个单词或者单个字符为主
> 3. 由于方法在调用时会绑定类型信息，因此命名以单个单词为主
> 4. 函数多以多个单词的复合词进行命名
> 5. 类型多以多个单词的复合词进行命名

多个词组成时局部变量`小驼峰`，对外导出`大驼峰`；单个词时用最简短的命名表示最大程度的意义，例如：i -> index、k -> key、v -> value，不过此种单字符命名一般出现在循环、条件变量中；命名中变量不要带有类型信息；保持变量声明与使用之间的距离越近越好，或者在第一次使用前再进行声明；接口名的命名一般是`方法+er`，并且在使用上，Go语言推荐尽量定义小接口，并且通过接口组合的方式构建程序。

## 声明形式

```flow
st=>start: 开始
op1=>operation: var a int32
op2=>operation: a :=17
op3=>operation: a :=(int32)17
op4=>operation: var a = 17
op5=>operation: var a = (int32)17
op6=>operation: var a int32
cond1=>condition: 包级变量?
cond2=>condition: 延迟初始化?
cond3=>condition: 是否使用默认类型?
cond4=>condition: 延迟初始化?
cond5=>condition: 是否使用默认类型?
st->cond1(yes)->cond2(yes)->op6
cond1(yes)->cond2(no)->cond3(yes)->op4
cond1(yes)->cond2(no)->cond3(no)->op5
cond1(no)->cond4(yes)->op1
cond1(no)->cond4(no)->cond5(yes)->op2
cond1(no)->cond4(no)->cond5(no)->op3
```

## 切片

切片是Go语言提供的重要且最常见的数据类型之一，可以将切片称之为`数组的描述符`，代替了数组，减少了数组指针作为函数参数的使用；append在切片上的运用让部分切片类型支持`零值可用`的理念，并且可动态扩容，减少使用者的底层存储内存分配工作；在可以预估切片容量的情况下，使用cap参数创建切片可以提升append的平均`操作性能`，减少频繁的动态扩容带来的性能损耗。

## 字典

字典也同样是Go语言提供的重要数据类型，使用中主要有几个要点需要注意：不能依赖于map的元素遍历顺序；map`不是线程安全`，`不支持并发写`（主要原因为底层数据结构`hmap中的flags`是`有状态`的，并且并没有做并发保护，由此并发写时会造成panic）；不要尝试获取map中元素（value）的地址；尽量使用`cap参数创建map`，以提升map的平均`访问性能`，减少频繁扩容带来的性能损耗。

## 求值顺序

#### 包级别变量表达式求值顺序

Go中，包级别变量的初始化按照变量声明的先后顺序进行；如果一个变量的初始化表达式中直接或间接以来其他变量，那么它的初始化顺序一定排在依赖的变量后边；未初始化的且不含有对应初始化表达式或者初始化表达式不依赖于任何未初始化变量，我们称之为`ready for initiation`变量；包级别变量的初始化是逐步进行的，每一步就是按照变量声明顺序找到下一个`ready for initiation`并对其初始化，直至没有`ready for initiation`为止。

#### 普通求值顺序

从左往右

#### 赋值语句求值顺序

先从左往右求值，后从左往右赋值

#### switch/select语句中的表达式求值

`惰性求值`即为需要对其求值时才会求值，能省则省，让计算机少做事，降低程序消耗。
